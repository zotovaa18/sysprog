------------------------------------------------------------------
Файловая система.
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

Нужно реализовать свою файловую систему в памяти. Не пугайтесь,
это не сложно. Для старта предоставляется шаблон интерфейса с
некоторыми уже реализованными структурами, в файлах userfs.h и
userfs.c.

Файловая система называется UserFS, и очень примитивна. В ней нет
папок - все файлы лежат в "руте". Файлы можно создавать, удалять,
открывать на них дескрипторы и закрывать их. Каждый файл похож по
структуре на файловую систему FAT: это список блоков. В userfs.c
можно посмотреть структуры, которые описывают блок и файл, где
лежит их список.

На диске не хранится ничего - все в оперативной памяти, на куче.
Файлы можно читать/писать по дескриптору. API очень похоже на
реальное из libc. Полное описание доступно в userfs.h.

Задача - реализовать это API так, как описано в комментариях в
userfs.h.


Правила:

- Нужно строго следовать поведению всех функций как оно описано в
  комментариях в userfs.h.


Ограничения:

- userfs.h нельзя менять кроме как для включения бонусов. Они
  описаны ниже.

- Тесты менять нельзя.

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.


Послабления:

- Можно полагать, что все данные помещаются в оперативную память,
  и функции ее выделения (такие как malloc()) всегда успешны.


Варианты решения:

- 15 баллов: реализовать все функции из userfs.h.

- +5 баллов: добавить поддержку режима открытия файла: для чтения,
  записи, и обоих операций вместе. См. NEED_OPEN_FLAGS в userfs.h
  и в тестах. Файловый дескриптор, открытый на чтение, не может
  быть использован для записи, и тоже самое обратно. По умолчанию
  файл должен открываться в режиме чтения-записи вместе.

- +5 баллов: добавить поддержку изменения размера файла. См.
  NEED_RESIZE в userfs.h.

- -5 баллов: (да, минус, не плюс) - можно использовать C++ и STL
  контейнеры.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10. Или использовать C++ и получать -5 к сумме.


Советы:

Ваша основная задача - реализовать увеличение файла по мере записи
в него, и реализовать файловый дескриптор. Рассмотрим пару
примеров.

Есть код:

        int fd = ufs_open("any_file_name", UFS_CREATE);

После этой строки внутри userfs.c создается struct file с именем
"any_file_name", если его еще нет. Затем создается файловый
дескриптор struct filedesc.

        const char *data = "bla bla bla";
        ufs_write(fd, data, strlen(data));

Файл пустой, в нем нет блоков, поэтому вам нужно аллоцировать
нужное число блоков struct block. В данном случае это 1. В него
копируем данные. Ваш файл начинает выглядеть так:

        file:
        +---------------------+
        | bla bla bla|        | -> NULL.
        +---------------------+
                     ^
                  filedesc - дескриптор указывает сюда. Например,
                             в дескрипторе вы можете хранить
                             номер блока и смещение в нем.

Затем я продолжаю писать, но уже больше данных:

        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ufs_write(fd, buf, sizeof(buf));

Вот что получится:

        file:
        +---------------------+    +---------------------+
        | bla bla bla 0 0 0 0 | -> | 0 0 0 0 0 0 0 0 0 0 | ->
        +---------------------+    +---------------------+

        +---------------------+
     -> | 0 0 0 0 0 0|        | -> NULL.
        +---------------------+
                     ^
                  filedesc

То есть понадобилось дозаполнить уже имеющийся блок, и создать еще
два блока. Они просто добавились в конец списка.

Тоже самое с чтениями - дескриптор читает последовательно
перепрыгивая на следующий блок, когда дочитал предыдущий.
