------------------------------------------------------------------
Пул потоков.
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

Нужно реализовать пул потоков. В разных программах, выполняющих
много независимых и легко распараллеливаемых задач часто бывает
удобно разносить их по разным потокам. Но создавать поток на
каждую необходимость что-то вынести в него довольно дорого по
времени и ресурсам. Если задача не слишком долгая, не читает диск,
сеть, то создание/удаление потока может занять больше времени, чем
сама задача.

Тогда обычно либо задачи вообще не параллелят, либо при их большом
количестве создают пул потоков. Это такой резерв рабочих потоков,
который имеет очередь задач и некое число потоков, которые с
очереди задачи забирают. Таким образом, можно всегда иметь под
рукой уже созданный поток, который может быстро подхватить любую
задачу, а в конце вместо завершения возьмет следующую.

В библиотеках часто есть уже готовое решение: в Qt это класс
QThreadPool, в .NET это класс ThreadPool, в boost это класс
thread_pool. В задании нужно реализовать свое, подобное.

В файлах thread_pool.h и thread_pool.c можно найти шаблоны функций
и структур, которые надо реализовать.

Пул потоков описывается структурой struct thread_pool,
реализованной в thread_pool.c, а у пользователя может быть на нее
только указатель. Каждая задача аналогично описывается структурой
struct thread_task, которые пользователь может создавать и класть
в пул в очередь.

Пользователь может проверять состояние задачи (ждет постановки в
поток; уже в потоке и выполняется), можно дождаться ее завершения
и получить результат при помощи thread_task_join, наподобие
pthread_join.

Поскольку задача - реализация библиотеки, то программы main нет, а
значит и принимать на вход некуда. Вы можете писать тесты на С, в
отдельном файле, где будет main, и куда будет делаться include
вашего решения. Например, создается файл main.c, который делает
include "thread_pool.h" и в функции main делает какие-то тесты.
Это все собирается так:

        gcc thread_pool.c main.c

Правила:

- thread_pool при создании через thread_pool_new() не должен сразу
  стартовать все потоки. Потоки должны создаваться по мере
  необходимости, пока не достигнут лимита, заданного пользователем
  в thread_pool_new().

- Присоединенные, но не удаленные таски могут быть пушнуты обратно
  в пул.

- Остальные правила можно увидеть в документации в thread_pool.h и
  понять из тестов.


Ограничения:

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.

- Код не должен содержать циклы активного ожидания (busy loops и
  sleep loops). Они разрешены только в тестах. То есть в
  thread_task_join() нельзя делать
  'while (!task->is_finished) {usleep(1)};'. Для ожидания чего
  либо нужно использовать pthread_cond_t.


Послабления:

- Нет лимита на количество мьютексов и условных переменных
  (condition variable). Можно даже иметь их в каждом таске.


Варианты решения:

- 15 баллов: реализовать все функции из thread_pool.h, которые не
  скрыты макросами.

- +5 баллов: реализовать thread_task_detach(). Документация есть в
  thread_pool.h. Нужно определить макрос NEED_DETACH.

- +5 баллов: реализовать thread_task_timed_join(). Документация
  есть в thread_pool.h. Нужно определить макрос NEED_TIMED_JOIN.

- -5 баллов: (да, минус, не плюс) - можно использовать C++, STL
  контейнеры, std::thread, std::mutex, и тд.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10. Или использовать C++ и получать -5 к сумме.
