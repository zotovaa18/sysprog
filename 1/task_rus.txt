------------------------------------------------------------------
Сортировка слиянием через корутины.
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

На диске лежат файлы. В них хранятся числа в произвольном порядке,
они разделены пробелами. Нужно отсортировать каждый файл и затем
слить их в один большой. То есть выполнить сортировку слиянием.


Правила:

- Каждый файл надо сортировать в отдельной корутине. Эта часть
  задания нацелена на понимание кооперативного планирования задач.

- Файлы имеют кодировку ASCII. То есть это обычный текст, не
  unicode или что-то такое.

- Для замеров времени нужно использовать
  clock_gettime(CLOCK_MONOTONIC). Немонотонные часы (такие как
  time(), gettimeofday(), CLOCK_REALTIME, и т.д.) могут иногда
  сдвигаться назад и портить измерения. clock() - тоже монотонный,
  но не учитывает время, проведенное в блокирующих системных
  вызовах.

- Код должен собираться успешно с данными флагами компилятора:
  `-Wextra -Werror -Wall -Wno-gnu-folding-constant`.


Ограничения:

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.

- Для сортировки нельзя использовать встроенные функции типа
  qsort(), system("sort ...") и тд.

- Сложность сортировки индивидуальных файлов должна быть < O(N^2)
  (например, нельзя использовать сортировку пузырьком). Однако
  можно выбрать любой алгоритм, покуда он удовлетворяет этому
  ограничению - допустим такую, как "быстрая сортировка".

- Суммарное время работы всей программы ограничено. Но так как у
  всех разное железо, то лимит относителен моего железа. На 2.5GHz
  CPU с SSD сортировка 6 файлов, каждый с 40к чисел, не должна
  занимать больше секунды. Вообще говоря, это должно быть
  100-200 мс или меньше, но секунда тоже подойдет.

- Работа с файлами должна быть

  - либо через числовые файловые дескрипторы и функции open() /
    read() / write() / close(),

  - либо через FILE* дескрипторы и функции fopen() / fscanf() /
    fprintf() / fclose(). Нельзя использовать std::iostream,
    std::ostream, std::istream и прочий STL.


Послабления:

- Числа помещаются в 'int'.

- Можно полагать, что все файлы помещаются целиком в память, даже
  все одновременно.

- Финальный шаг - само слияние сортированных массивов - можно
  делать прямо в main() снаружи от корутин.


Советы:

- Вы можете найти больше информации о разных новых функциях при
  помощи консольной команды 'man'. Наример, 'man read' (или
  'man 2 read') напечатает документацию функции 'read()'.
  'man strdup' расскажет больше про функцию 'strdup()'. Таким же
  образом можно искать другие встроенные функции.

- Шаги, которым можно следовать, если не знаете, с чего начать:

  - Реализовать обычную сортировку одного файла. Без корутин, без
    множества файлов. Просто прочитать и отсортировать один файл.
    Протестируйте этот код.

  - Расширьте свой код, чтобы теперь он сортировал много файлов
    через сортировку слиянием. Без корутин. Проверьте свой код на
    реальных тестах из задания. Когда он заработает, вы сможете
    сконцентрироваться на добавлении корутин, и не тратить время
    на отладку одновременно и корутин, и сортировки, и работы с
    файлами.

  - Встройте в свой код корутины.


Варианты решения:

Корутины должны переключаться. Делать так называемые 'yield',
'илды'. Это делается при помощи coro_yield() в файле solution.c.
Есть несколько опций, как именно пользоваться илдами:

- 15 баллов: yield после каждой итерации циклов сортировки
  индивидуальных файлов.

- +5 баллов: каждая из N корутин получает T / N микросекунд, где
  T - target latency введенное как параметр командной строки.
  После каждой итерации сортировки вы делаете yield только если
  квант времени текущей корутины закончился.

- +5 баллов: позволить задавать количество корутин. Каждая
  корутина должна работать вот так: если есть еще не
  отсортированные файлы, то взять один, отсортировать, повторить.
  Если все файлы отсортированы, то корутина завершается. Например,
  предположим, что есть 10 файлов и 3 корутины. Они берут по
  одному файлу, осталось еще 7. Одна корутина закончила свой файл,
  взяла следующий файл (6 файлов осталось). Еще одна корутина
  закончила другой файл и взяла следующий (5 файлов осталось). И
  так далее, пока все файлы не отсортированы. Затем вы делаете
  обычную сортировку слиянием. Этот бонус по сути предлагает вам
  реализовать пул (pool) корутин.

- -5 баллов: (да, минус, не плюс) - можно использовать C++ и STL
  контейнеры.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10. Или использовать C++ и получать -5 к сумме.

Ввод: имена файлов для сортировки через аргументы командной
строки. Если делаете бонусные задания, то так же через командную
строку передаются target latency в микросекундах (если делаете
этот бонус) и количество корутин (если делаете этот бонус) перед
именами файлов.

Вывод: суммарное время работы программы, время работы и количество
переключений каждой корутины. Учтите, что время работы корутины не
включает ее время ожидания. То есть пока она спала во время
coro_yield(). Вы должны остановить таймер работы корутины прямо
перед coro_yield() и возобновить его сразу после.

Для тестирования можно создать свои файлы или генерировать их при
помощи скрипта generator.py. Пример, который должен работать на
15 баллов:

$> python3 generator.py -f test1.txt -c 10000 -m 10000
$> python3 generator.py -f test2.txt -c 10000 -m 10000
$> python3 generator.py -f test3.txt -c 10000 -m 10000
$> python3 generator.py -f test4.txt -c 10000 -m 10000
$> python3 generator.py -f test5.txt -c 10000 -m 10000
$> python3 generator.py -f test6.txt -c 100000 -m 10000

$> ./main test1.txt test2.txt test3.txt test4.txt test5.txt test6.txt

Для проверки результата можно использовать скрипт checker.py. Все
скрипты используют python 3.
